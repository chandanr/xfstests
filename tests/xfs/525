#! /bin/bash
# SPDX-License-Identifier: GPL-2.0
# Copyright (c) 2020 YOUR NAME HERE.  All Rights Reserved.
#
# FS QA Test 525
#
# what am I here for?
#
seq=`basename $0`
seqres=$RESULT_DIR/$seq
echo "QA output created by $seq"

here=`pwd`
tmp=/tmp/$$
status=1	# failure is the default!
trap "_cleanup; exit \$status" 0 1 2 3 15

_cleanup()
{
	cd /
	rm -f $tmp.*
}

# get standard environment, filters and checks
. ./common/rc
. ./common/filter

# remove previous $seqres.full before test
rm -f $seqres.full

# real QA test starts here

_supported_fs xfs
_require_scratch

dir_entry_create()
{
	echo "* Create directory entries"

	echo "Format and mount fs"
	_scratch_mkfs_sized $((512 * 1024 * 1024)) | _filter_mkfs >> $seqres.full 2> $tmp.mkfs
	_scratch_mount >> $seqres.full

	. $tmp.mkfs

	# Any dir block size greater than one fsb in size, will not be allowed
	# to get created, since 7 * 2 = 14 > 10.  Extending false max limit
	# won't help much.  Consider the case where 1fsb is 1k in size and 1 dir
	# block is 64k fsb count = 65536 / 1024 = 64; Hence false max limit has
	# to be > (64 * 7 = 448).
	if (( $dbsize != $dirbsize )); then
		_notrun "Mismatching fsb size ($dbsize) and directory block size ($dirbsize)"
	fi

	testfile=$SCRATCH_MNT/testfile

	echo "Consume free space"
	dd if=/dev/zero of=${testfile} bs=${dbsize} >> $seqres.full 2>&1
	sync

	echo "Create fragmented filesystem"
	$here/src/punch-alternating $testfile >> $seqres.full
	sync

	echo "Inject reduce_max_iextents error tag"
	xfs_io -x -c 'inject reduce_max_iextents' $SCRATCH_MNT

	echo "Inject bmap_alloc_minlen_extent error tag"
	xfs_io -x -c 'inject bmap_alloc_minlen_extent' $SCRATCH_MNT

	echo "Create directory entries"
	dent_len=$(uuidgen | wc -c)
	nr_dents=$((dbsize * 20 / dent_len))
	for i in $(seq 1 $nr_dents); do
		touch $SCRATCH_MNT/$(uuidgen) >> $seqres.full 2>&1 || break
	done

	dirino=$(stat -c "%i" $SCRATCH_MNT)

	_scratch_unmount >> $seqres.full

	echo "Verify directory's extent count"
	nextents=$(_scratch_xfs_db  -c "inode $dirino" -c "print core.nextents")
	nextents=${nextents##core.nextents = }

	if (( $nextents > 10 )); then
		echo "Extent count overflow check failed: nextents = $nextents"
	fi
}

# Rename: Populate destination directory
dir_entry_rename_dst()
{
	echo "* Rename: Populate destination directory"

	echo "Format and mount fs"
	_scratch_mkfs_sized $((512 * 1024 * 1024)) | _filter_mkfs >> $seqres.full 2> $tmp.mkfs
	_scratch_mount >> $seqres.full

	. $tmp.mkfs

	# Any dir block size greater than one fsb in size, will not be allowed
	# to get created, since 7 * 2 = 14 > 10.  Extending false max limit
	# won't help much.  Consider the case where 1fsb is 1k in size and 1 dir
	# block is 64k fsb count = 65536 / 1024 = 64; Hence false max limit has
	# to be > (64 * 7 = 448).
	if (( $dbsize != $dirbsize )); then
		_notrun "Mismatching fsb size ($dbsize) and directory block size ($dirbsize)"
	fi

	testfile=$SCRATCH_MNT/testfile

	echo "Consume free space"
	dd if=/dev/zero of=${testfile} bs=${dbsize} >> $seqres.full 2>&1
	sync

	echo "Create fragmented filesystem"
	$here/src/punch-alternating $testfile >> $seqres.full
	sync

	echo "Inject reduce_max_iextents error tag"
	xfs_io -x -c 'inject reduce_max_iextents' $SCRATCH_MNT

	echo "Inject bmap_alloc_minlen_extent error tag"
	xfs_io -x -c 'inject bmap_alloc_minlen_extent' $SCRATCH_MNT

	dstdir=$SCRATCH_MNT/dstdir
	mkdir $dstdir

	dent_len=$(uuidgen | wc -c)
	nr_dents=$((dirbsize * 20 / dent_len))

	echo "Populate \$dstdir by mv-ing new directory entries"
	for i in $(seq 1 $nr_dents); do
		file=${SCRATCH_MNT}/$(uuidgen)
		touch $file || break
		mv $file $dstdir >> $seqres.full 2>&1 || break
	done

	dirino=$(stat -c "%i" $dstdir)

	_scratch_unmount >> $seqres.full

	echo "Verify \$dstdir's extent count"
	nextents=$(_scratch_xfs_db  -c "inode $dirino" -c "print core.nextents")
	nextents=${nextents##core.nextents = }

	if (( $nextents > 10 )); then
		echo "Extent count overflow check failed: nextents = $nextents"
	fi
}

# Rename: Populate source directory and mv one entry to destination directory
dir_entry_rename_src()
{
	echo "* Rename: Populate source directory and mv one entry to destination directory"

	echo "Format and mount fs"
	_scratch_mkfs_sized $((512 * 1024 * 1024)) | _filter_mkfs >> $seqres.full 2> $tmp.mkfs
	_scratch_mount >> $seqres.full

	. $tmp.mkfs

	# Any dir block size greater than one fsb in size, will not be allowed
	# to get created, since 7 * 2 = 14 > 10.  Extending false max limit
	# won't help much.  Consider the case where 1fsb is 1k in size and 1 dir
	# block is 64k fsb count = 65536 / 1024 = 64; Hence false max limit has
	# to be > (64 * 7 = 448).
	if (( $dbsize != $dirbsize )); then
		_notrun "Mismatching fsb size ($dbsize) and directory block size ($dirbsize)"
	fi

	testfile=$SCRATCH_MNT/testfile

	echo "Consume free space"
	dd if=/dev/zero of=${testfile} bs=${dbsize} >> $seqres.full 2>&1
	sync

	echo "Create fragmented filesystem"
	$here/src/punch-alternating $testfile >> $seqres.full
	sync

	srcdir=${SCRATCH_MNT}/srcdir
	dstdir=${SCRATCH_MNT}/dstdir

	mkdir $srcdir $dstdir

	dirino=$(stat -c "%i" $srcdir)

	dent_len=$(uuidgen | wc -c)
	nr_dents=$((dirbsize / dent_len))
	nextents=0
	last=""

	echo "Populate \$srcdir with atleast 4 extents"
	while (( $nextents < 4 )); do
		xfs_io -x -c 'inject bmap_alloc_minlen_extent' $SCRATCH_MNT

		for i in $(seq 1 $nr_dents); do
			last=${srcdir}/$(uuidgen)
			touch $last || break
		done

		_scratch_unmount >> $seqres.full

		nextents=$(_scratch_xfs_db  -c "inode $dirino" -c "print core.nextents")
		nextents=${nextents##core.nextents = }

		_scratch_mount >> $seqres.full
	done

	echo "Inject reduce_max_iextents error tag"
	xfs_io -x -c 'inject reduce_max_iextents' $SCRATCH_MNT

	echo "Move an entry from \$srcdir to trigger -EFBIG"
	mv $last $dstdir >> $seqres.full 2>&1
	if [[ $? == 0 ]]; then
		echo "Moving from \$srcdir to \$dstdir succeeded; Should have failed"
	fi

	_scratch_unmount >> $seqres.full
}

dir_entry_create_hard_links()
{
	echo "* Create multiple hard links to a single file"

	echo "Format and mount fs"
	_scratch_mkfs_sized $((512 * 1024 * 1024)) | _filter_mkfs >> $seqres.full 2> $tmp.mkfs
	_scratch_mount >> $seqres.full

	. $tmp.mkfs

	# Any dir block size greater than one fsb in size, will not be allowed
	# to get created, since 7 * 2 = 14 > 10.  Extending false max limit
	# won't help much.  Consider the case where 1fsb is 1k in size and 1 dir
	# block is 64k fsb count = 65536 / 1024 = 64; Hence false max limit has
	# to be > (64 * 7 = 448).
	if (( $dbsize != $dirbsize )); then
		_notrun "Mismatching fsb size ($dbsize) and directory block size ($dirbsize)"
	fi

	testfile=$SCRATCH_MNT/testfile

	echo "Consume free space"
	dd if=/dev/zero of=${testfile} bs=${dbsize} >> $seqres.full 2>&1
	sync

	echo "Create fragmented filesystem"
	$here/src/punch-alternating $testfile >> $seqres.full
	sync

	echo "Inject reduce_max_iextents error tag"
	xfs_io -x -c 'inject reduce_max_iextents' $SCRATCH_MNT

	echo "Inject bmap_alloc_minlen_extent error tag"
	xfs_io -x -c 'inject bmap_alloc_minlen_extent' $SCRATCH_MNT

	dent_len=$(uuidgen | wc -c)
	nr_dents=$((dirbsize * 20 / dent_len))

	echo "Create multiple hardlinks"
	for i in $(seq 1 $nr_dents); do
		ln $testfile ${SCRATCH_MNT}/$(uuidgen) >> $seqres.full 2>&1 || break
	done

	dirino=$(stat -c "%i" $SCRATCH_MNT)

	_scratch_unmount >> $seqres.full

	echo "Verify directory's extent count"
	nextents=$(_scratch_xfs_db  -c "inode $dirino" -c "print core.nextents")
	nextents=${nextents##core.nextents = }

	if (( $nextents > 10 )); then
		echo "Extent count overflow check failed: nextents = $nextents"
	fi
}	

dir_entry_create_symlinks()
{
	echo "* Create multiple symbolic links to a single file"

	echo "Format and mount fs"
	_scratch_mkfs_sized $((512 * 1024 * 1024)) | _filter_mkfs >> $seqres.full 2> $tmp.mkfs
	_scratch_mount >> $seqres.full

	. $tmp.mkfs

	# Any dir block size greater than one fsb in size, will not be allowed
	# to get created, since 7 * 2 = 14 > 10.  Extending false max limit
	# won't help much.  Consider the case where 1fsb is 1k in size and 1 dir
	# block is 64k fsb count = 65536 / 1024 = 64; Hence false max limit has
	# to be > (64 * 7 = 448).
	if (( $dbsize != $dirbsize )); then
		_notrun "Mismatching fsb size ($dbsize) and directory block size ($dirbsize)" >> $seqres.full
	fi

	testfile=$SCRATCH_MNT/testfile

	echo "Consume free space"
	dd if=/dev/zero of=${testfile} bs=${dbsize} >> $seqres.full 2>&1
	sync

	echo "Create fragmented filesystem"
	$here/src/punch-alternating $testfile >> $seqres.full
	sync

	echo "Inject reduce_max_iextents error tag"
	xfs_io -x -c 'inject reduce_max_iextents' $SCRATCH_MNT

	echo "Inject bmap_alloc_minlen_extent error tag"
	xfs_io -x -c 'inject bmap_alloc_minlen_extent' $SCRATCH_MNT

	dent_len=$(uuidgen | wc -c)
	nr_dents=$((dirbsize * 20 / dent_len))

	echo "Create multiple symbolic links"
	for i in $(seq 1 $nr_dents); do
		ln -s $testfile ${SCRATCH_MNT}/$(uuidgen) >> $seqres.full 2>&1 || break;
	done

	dirino=$(stat -c "%i" $SCRATCH_MNT)

	_scratch_unmount >> $seqres.full

	echo "Verify directory's extent count"
	nextents=$(_scratch_xfs_db  -c "inode $dirino" -c "print core.nextents")
	nextents=${nextents##core.nextents = }

	if (( $nextents > 10 )); then
		echo "Extent count overflow check failed: nextents = $nextents"
	fi
}

dir_entry_remove()
{
	echo "* Populate a directory and remove one entry"

	echo "Format and mount fs"
	_scratch_mkfs_sized $((512 * 1024 * 1024)) | _filter_mkfs >> $seqres.full 2> $tmp.mkfs
	_scratch_mount >> $seqres.full

	. $tmp.mkfs

	# Any dir block size greater than one fsb in size, will not be allowed
	# to get created, since 7 * 2 = 14 > 10.  Extending false max limit
	# won't help much.  Consider the case where 1fsb is 1k in size and 1 dir
	# block is 64k fsb count = 65536 / 1024 = 64; Hence false max limit has
	# to be > (64 * 7 = 448).
	if (( $dbsize != $dirbsize )); then
		_notrun "Mismatching fsb size ($dbsize) and directory block size ($dirbsize)" >> $seqres.full
	fi

	testfile=$SCRATCH_MNT/testfile

	echo "Consume free space"
	dd if=/dev/zero of=${testfile} bs=${dbsize} >> $seqres.full 2>&1
	sync

	echo "Create fragmented filesystem"
	$here/src/punch-alternating $testfile >> $seqres.full
	sync

	dirino=$(stat -c "%i" $SCRATCH_MNT)

	dent_len=$(uuidgen | wc -c)
	nr_dents=$((dirbsize / dent_len))
	nextents=0
	last=""

	echo "Populate directory with atleast 4 extents"
	while (( $nextents < 4 )); do
		xfs_io -x -c 'inject bmap_alloc_minlen_extent' $SCRATCH_MNT

		for i in $(seq 1 $nr_dents); do
			last=${SCRATCH_MNT}/$(uuidgen)
			touch $last || break
		done

		_scratch_unmount >> $seqres.full

		nextents=$(_scratch_xfs_db  -c "inode $dirino" -c "print core.nextents")
		nextents=${nextents##core.nextents = }

		_scratch_mount >> $seqres.full
	done

	echo "Inject reduce_max_iextents error tag"
	xfs_io -x -c 'inject reduce_max_iextents' $SCRATCH_MNT

	echo "Remove an entry from directory to trigger -EFBIG"
	rm $last >> $seqres.full 2>&1
	if [[ $? == 0 ]]; then
		echo "Removing file succeeded; Should have failed"
	fi

	_scratch_unmount >> $seqres.full
}

dir_entry_create
dir_entry_rename_dst
dir_entry_rename_src
dir_entry_create_hard_links
dir_entry_create_symlinks
dir_entry_remove

# success, all done
status=0
exit
